<h2>《C++ Primer Plus (第6版)》 :books: </h2> 

> [美] Stephen Prata 著    人民邮电出版社

```c++
1.4 种让程序访问名称空间 std 的方法：
  (1) 将 using namespace std; 放在函数定义之前，让文件中所有的函数都能够使用名称空间 std 中所有元素。
  (2) 将 using namespace std; 放在特定的函数定义中，让该函数能够使用名称空间 std 中的所有元素。
  (3) 在特定的函数中使用类似 using std::cout; 这样的编译指令，而不是 using namespace std;，
让该函数能够使用指定的元素。
  (4) 完全不使用编译指令 using，而在需要使用名称空间 std 中的元素时，使用前缀 std::，
如：std::cout << "test" << std::endl;

2.使用 new 和 delete 时的规则：
  (1) 不要使用 delete 来释放不是 new 分配的内存。
  (2) 不要使用 delete 释放同一个内存块两次。
  (3) 如果使用 new[] 为数组分配内存，则应使用 delete[] 来释放。
  (4) 如果使用 new 为一个实体分配内存，则应使用 delete (没有方括号) 来释放。
  (5) 对空指针应用 delete 是安全的。
  
3.函数：
  (1) 函数是 C++ 的编程模块。要使用函数，必须提供定义和原型，并调用该函数。函数定义是实现函数功能的代码；
函数原型描述了函数的接口：传递给函数的值的数目和种类以及函数的返回类型。函数调用使得程序将参数传递给函数，
并执行函数的代码。
  (2) 在默认情况下，C++ 函数按值传递参数。这意味着函数定义中的形参是新的变量，它们被初始化为函数调用所提供的值。
因此，C++ 函数通过使用拷贝，保护了原始数据的完整性。
  (3) C++ 将数组名视为数组第一个元素的地址。从技术上讲，这仍然是按值传递的，因为指针是原始地址的拷贝，
但函数将使用指针来访问原始数组的内容。当且仅当声明函数的形参时，下面两个声明才是等价的：
   typeName arr[];
   typeName * arr;
  这两个声明都表明，arr 是指向 typeName 的指针，但在编写函数代码时，可以像使用数组名那样使用 arr 来访问元素：arr[i]。
即使在传递指针时，也可以将形参声明为 const 指针，来保护原始数据的完整性。由于传递数据的地址时，并不会传输有关数组长度
的信息，因此通常将数组长度作为独立的参数来传递。另外也可传递两个指针(其中一个指向数组开头，
另一个指向数组末尾的下一个元素)，以指定一个范围，就像 STL 使用的算法一样。
  (4) C++ 提供了 3 种表示 C-风格字符串的方法：字符数组、字符串常量和字符串指针。它们的类型都是 char* (char 指针)，
因此被作为 char* 类型参数传递给函数。C++ 使用空值字符 (\0) 来结束字符串，因此字符串函数检测空值字符来确定字符串的结尾。
  (5) C++ 还提供了 string 类，用于表示字符串。函数可以接受 string 对象作为参数以及将 string 对象作为返回值。
string 类的方法 size() 可用于判断其存储的字符串的长度。
  (6) C++ 处理结构的方式与基本类型完全相同，这意味着可以按值传递结构，并将其用作函数的返回类型。然而，如果结构非常大，
则传递结构指针的效率将更高，同时函数能够使用原始数据。这些考虑因素也适用于类对象。
  (7) C++ 函数可以是递归的，也就是说，函数代码中可以包括对函数本身的调用。
  (8) C++ 函数名与函数地址的作用相同。通过将函数指针作为参数，可以传递要调用的函数的名称。
  (9) C++ 扩展了 C 语言的函数功能。通过将 inline 关键字用于函数定义，并在首次调用该函数前提供其函数定义，可以使得
C++ 编译器将该函数视为内联函数。也就是说，编译器不是让程序跳到独立的代码段，以执行函数，而是用相应的代码替换函数调用。
只有在函数很短时才能采用内联方式。
```
