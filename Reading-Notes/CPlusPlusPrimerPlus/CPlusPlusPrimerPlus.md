<h2>《C++ Primer Plus (第6版)》 :books: </h2> 

> [美] Stephen Prata 著    人民邮电出版社

```c++
1.4 种让程序访问名称空间 std 的方法：
  (1) 将 using namespace std; 放在函数定义之前，让文件中所有的函数都能够使用名称空间 std 中所有元素。
  (2) 将 using namespace std; 放在特定的函数定义中，让该函数能够使用名称空间 std 中的所有元素。
  (3) 在特定的函数中使用类似 using std::cout; 这样的编译指令，而不是 using namespace std;，
让该函数能够使用指定的元素。
  (4) 完全不使用编译指令 using，而在需要使用名称空间 std 中的元素时，使用前缀 std::，
如：std::cout << "test" << std::endl;

2.使用 new 和 delete 时的规则：
  (1) 不要使用 delete 来释放不是 new 分配的内存。
  (2) 不要使用 delete 释放同一个内存块两次。
  (3) 如果使用 new[] 为数组分配内存，则应使用 delete[] 来释放。
  (4) 如果使用 new 为一个实体分配内存，则应使用 delete (没有方括号) 来释放。
  (5) 对空指针应用 delete 是安全的。
  
3.函数探幽：
  (1) 函数是 C++ 的编程模块。要使用函数，必须提供定义和原型，并调用该函数。函数定义是实现函数功能的代码；
函数原型描述了函数的接口：传递给函数的值的数目和种类以及函数的返回类型。函数调用使得程序将参数传递给函数，
并执行函数的代码。
  (2) 在默认情况下，C++ 函数按值传递参数。这意味着函数定义中的形参是新的变量，它们被初始化为函数调用所提供的值。
因此，C++ 函数通过使用拷贝，保护了原始数据的完整性。
  (3) C++ 将数组名视为数组第一个元素的地址。从技术上讲，这仍然是按值传递的，因为指针是原始地址的拷贝，
但函数将使用指针来访问原始数组的内容。当且仅当声明函数的形参时，下面两个声明才是等价的：
   typeName arr[];
   typeName * arr;
  这两个声明都表明，arr 是指向 typeName 的指针，但在编写函数代码时，可以像使用数组名那样使用 arr 来访问元素：arr[i]。
即使在传递指针时，也可以将形参声明为 const 指针，来保护原始数据的完整性。由于传递数据的地址时，并不会传输有关数组长度
的信息，因此通常将数组长度作为独立的参数来传递。另外也可传递两个指针(其中一个指向数组开头，
另一个指向数组末尾的下一个元素)，以指定一个范围，就像 STL 使用的算法一样。
  (4) C++ 提供了 3 种表示 C-风格字符串的方法：字符数组、字符串常量和字符串指针。它们的类型都是 char* (char 指针)，
因此被作为 char* 类型参数传递给函数。C++ 使用空值字符 (\0) 来结束字符串，因此字符串函数检测空值字符来确定字符串的结尾。
  (5) C++ 还提供了 string 类，用于表示字符串。函数可以接受 string 对象作为参数以及将 string 对象作为返回值。
string 类的方法 size() 可用于判断其存储的字符串的长度。
  (6) C++ 处理结构的方式与基本类型完全相同，这意味着可以按值传递结构，并将其用作函数的返回类型。然而，如果结构非常大，
则传递结构指针的效率将更高，同时函数能够使用原始数据。这些考虑因素也适用于类对象。
  (7) C++ 函数可以是递归的，也就是说，函数代码中可以包括对函数本身的调用。
  (8) C++ 函数名与函数地址的作用相同。通过将函数指针作为参数，可以传递要调用的函数的名称。
  (9) C++ 扩展了 C 语言的函数功能。通过将 inline 关键字用于函数定义，并在首次调用该函数前提供其函数定义，可以使得
C++ 编译器将该函数视为内联函数。也就是说，编译器不是让程序跳到独立的代码段，以执行函数，而是用相应的代码替换函数调用。
只有在函数很短时才能采用内联方式。
  (10) 引用变量是一种伪装指针，它允许为变量创建别名。引用变量主要被用作处理结构和类对象的函数参数。通常，
被声明为特定类型引用的标识符只能指向这种类型的数据；然而，如果一个类 (如 ofstream) 是从另一个类 (如 ostream) 派生
出来的，则基类引用可以指向派生类对象。
  (11) C++ 原型让您能够定义参数的默认值。如果函数调用省略了相应的参数，则程序将使用默认值；如果函数调用提供了参数值，
则程序将使用这个值 (而不是默认值)。只能在参数列表中从右到左提供默认参数。因此，如果为某个参数提供默认值，则必须为该
参数右边所有的参数提供默认值。
  (12) 函数的特征标是其参数列表。程序员可以定义两个同名函数，只要其特征标不同。这被称为函数多态或函数重载。通常，
通过重载函数来为不同的数据类型提供相同的服务。
  (13) 函数模板自动完成重载函数的过程。只需使用泛型和具体算法来定义函数，编译器将为程序中使用的特定参数类型生成正确
的函数定义。

4.应尽可能使用 const。
  将引用参数声明为常量数据的引用的理由有三个：
  (1) 使用 const 可以避免无意中修改数据的编程错误；
  (2) 使用 const 使函数能够处理 const 和非 const 实参，否则将只能接受非 const 数据；
  (3) 使用 const 引用使函数能够正确生成并使用临时变量。

5.何时使用引用参数?
  (1) 使用引用参数的两个主要原因：
    ① 程序员能够修改调用函数中的数据对象。
    ② 通过传递引用而不是整个数据对象，可以提高程序的运行速度。
  (2) 对于使用传递的值而不作修改的函数：
    ① 如果数据对象很小，如内置数据类型或小型结构，则按值传递。
    ② 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向 const 的指针。
    ③ 如果数据对象是较大的结构，则使用 const 指针或 const 引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。
    ④ 如果数据对象是类对象，则使用 const 引用。类设计的语义常常要求使用引用，这是 C++ 新增这项特性的主要原因。因此，
传递类对象参数的标准方式是按引用传递。
  (3) 对于修改调用函数中数据的函数：
    ① 如果数据对象是内置数据类型，则使用指针。如果看到诸如 fixit(&x) 这样的代码 (其中 x 是 int)，则很明显，
该函数将修改 x。
    ② 如果数据对象是数组，则只能使用指针。
    ③ 如果数据对象是结构，则使用引用或指针。
    ④ 如果数据对象是类对象，则使用引用。

6.第三代具体化 (ISO/ANSI C++ 标准)。
   (1) 对于给定的函数名，可以有非模板函数 (non template function)、模板函数 (template prototype) 和显示具体化模板函数
(explicit specialization) 以及它们的重载版本。
   (2) 显示具体化的原型和定义应以 template<> 打头，并通过名称来指出类型。
   (3) 具体化优先于常规模版，而非模版函数优先于具体化和常规模板。
   // 非模板函数 (non template function)
   void Swap(job &, job &);
   // 模板函数 (template prototype)
   template <typename T>
   void Swap(T &, T &);
   // 显示具体化模板函数 (explicit specialization) 
   template <> void Swap<job>(job &, job &);
```
