<h2>《Java 并发编程实战》 :books: </h2> 
> Brian Goetz、 Tim Peierls、 Joshua Bloch、 Joseph Bowbeer、 David Holmes、 Doug Lea 著   

```html
  1.什么是线程安全？
    当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的
  同步和协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。
    在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。
    无状态对象一定是线程安全的。
  
  2.原子性：
    ++count：“读取-修改-写入”的操作序列，其结果状态依赖之前的状态。
    竞态条件：最常见的竞态条件-“先检查后执行(Check-Then-Act)”操作，即通过一个可能失效的观测结果来决定下一步的动作。
    复合操作：“先检查后执行(Check-Then-Act)”和“读取-修改-写入”(例如递增运算)等操作统称为复合操作。
    假设有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此
  来说是原子的。原子操作是指，对于访问同一个状态的所有操作(包括该操作本身)来说，这个操作是一个以原子方式执行的操作。
    在实际情况中，应尽可能地使用现有的线程安全对象(例如AcomicLong)来管理类的状态。与非线程安全的对象相比，判断线程安全
  对象的可能状态及其状态转换情况要更为容易，从而也更容易维护和验证线程安全性。
   
  3.加锁机制：
    要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。
    内置锁：静态的 synchronized 方法以 Class 对象作为锁。
    “重入”意味着获取锁的操作的粒度是“线程”，而不是调用。
  
  4.用锁来保护状态： 
    对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的.
    每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。
    对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。
    
```
